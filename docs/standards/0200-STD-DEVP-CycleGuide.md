# [STD-DEVP-CycleGuide] 開発サイクルガイド（統合版・汎用標準）
**Version:** v2.1.0  
**Date:** 2025-10-09  
**Status:** Draft  

---

## 1. 表紙情報
- 文書番号: `STD-DEVP-CycleGuide`  
- バージョン: **v2.1.0**  
- 日付: 2025-10-09  
- 状態: Draft  

**準拠文書:**  
- STD-DEVP（開発プロセス標準・汎用版）  
- STD-DEVP-Principles（一般原則）  
- STD-DEVP-MethodsReference（手法解説集）  

---

## 2. 目的と位置づけ
本書は、開発プロセスを**手法の寄せ集めではなく「循環する体系」**として理解し、  
その中心にある「仕様・テスト・実装が常に整合し続けるサイクル」を確立するための指針を示す。

本ガイドの目的は、**このサイクル（Spec–Conformance Cycle）を止めないこと**にある。  
そのために、既存の開発手法（RFC2119／BDD／TDD／Contract-First／Conformance Testing）を「手段」として再構成する。  
各手法の採用には明確な理由と役割があり、単独導入ではなく相互補完的に運用することを前提とする。

---

## 3. ゴール：Spec–Conformance Cycle

```
 ┌───────────────┐
 │  仕様 (Spec)  │  ←─ RFC2119 により要求強度を明示
 └───────┬───────┘
         │
         ▼
 ┌───────────────┐
 │  契約 (Contract)│ ←─ Contract-First によりIF・DTOを確定
 └───────┬───────┘
         │
         ▼
 ┌───────────────┐
 │  テスト (Test) │ ←─ BDD により例と期待結果を具現化
 └───────┬───────┘
         │
         ▼
 ┌───────────────┐
 │  実装 (Impl)  │ ←─ TDD により最小実装を導出
 └───────┬───────┘
         │
         ▼
 ┌───────────────┐
 │ 適合確認 (Conf.)│ ←─ Conformance Testing により妥当性検証
 └───────┬───────┘
         │
         ▼
 ┌───────────────┐
 │ フィードバック │ ←─ 実装結果を仕様へ還流
 └───────────────┘
```

このループが継続的に回ることで、  
**仕様・テスト・実装が乖離しない開発プロセス（SCD: Spec–Conformance Development）** が維持される。  
つまり開発の目的は「サイクルの連続稼働」であり、各手法はそのための潤滑機構である。

---

## 4. サイクルの6段階と目的

| 段階 | ゴール | 主な手法・支援概念 | 採用理由 |
|------|----------|----------------|------------|
| ① 仕様定義 | 機能・非機能を明確にし、テスト可能な単位に分解 | RFC2119（MUST/SHOULD/MAY） | 曖昧さを排除し、要求の強度を機械的に判定可能にするため。 |
| ② 契約確立 | 公開IF・DTO・例外を確定し、変更影響を局所化 | Contract-First | 設計の再現性を高め、境界の安定性を維持するため。 |
| ③ テスト策定 | 期待動作をExampleで具体化 | BDD / Specification by Example | 仕様を自然言語で共有し、実行可能仕様として扱うため。 |
| ④ 実装 | テストを通す最小コードから設計を洗練 | TDD | テストを先行させ、設計の品質を安全に進化させるため。 |
| ⑤ 適合確認 | ReqID単位で仕様遵守を検証しCIで可視化 | Conformance Testing | 自動で仕様整合性を監視し、品質を定量保証するため。 |
| ⑥ フィードバック | 実装/テスト結果を仕様に反映し、Matrixを更新 | Traceability + CI/CD | サイクルを途切れさせず、仕様を常に最新化するため。 |

---

## 5. 各段階の詳細解説（統合的手法解釈）

### 5.1 仕様定義（Define Specification）
**目的:** 実装が誤解なく導ける最小単位で要求を明確化する。  
**採用理由:** RFC2119キーワード（MUST／SHOULD／MAY）を用いて要求の強度を標準化することで、曖昧な表現を防ぎ、CIなどによる自動検証を可能にするため。  
**キーワード解説:**  
- **MUST:** 絶対条件。テスト必須の仕様要求。  
- **SHOULD:** 望ましい条件。設計上の推奨事項。  
- **MAY:** 任意実装可。互換性や拡張性を示す。  

- 各要求は **1観点＝1ReqID** とする。  
- RFC2119キーワードで強度を明示することで、レビュー・機械検証を容易にする。  
- 例：  
  ```
  API-R001: サービスは HTTP 429 を検出した場合、再試行ポリシーを適用すること MUST.
  ```
- 要求文は「テスト可能」であることが条件。  
- この段階で仕様が曖昧なまま次工程に進むことは**禁止（MUST NOT）**。

**全体解説:**  
仕様定義は、Spec–Conformance Cycle の出発点であり、後続の契約・テスト・実装の品質を決定づける。  
RFC2119による要求強度の明示は単なる表現規約ではなく、整合性を維持するための**制御装置**である。  

- **サイクル内での位置づけ:**  
  - Contract段階では、MUST要件が契約仕様の必須項目として固定される。  
  - Test段階では、BDDシナリオのGiven条件として要求文が反映される。  
  - Impl段階では、MUST要件を満たさないコードはCIで検出され、マージが拒否される。  

- **実務適用例:**  
  - 仕様書やストーリー記述にRFC2119語を用いて明確化。  
  - LinterやCIスクリプトでMUST/SHOULD/MAYを自動抽出し、Conformance Matrixに反映。  

- **意義:**  
  仕様定義が曖昧であれば、整合性サイクルは機能しない。  
  仕様定義は「開発の起点」であると同時に、「整合性を継続保証する最初の防衛線」である。  

---

### 5.2 契約確立（Define Contract）
**目的:** 実装やテストが依存する共有境界を明確化する。  
**採用理由:** Contract-Firstを採用することで、実装前にAPI契約（Interface／DTO）を確定し、依存関係を局所化して設計変更リスクを低減するため。  
**キーワード解説:**  
- **Interface:** 実装と外部をつなぐ公開契約。  
- **DTO (Data Transfer Object):** データ構造の共有定義。  
- **Schema:** 契約内容の形式的仕様書。  
- **Single Source of Truth:** 契約が唯一の信頼情報源であるという原則。  

- Public API／DTO／例外を「契約 (Contract)」として定義。  
- **Contract-First** の考え方を採用し、契約が唯一の真実源（Single Source of Truth）。  
- 自動生成されるコードは**改変禁止（MUST NOT）**。  
- 設計変更時はADRを作成し、契約バージョンを管理する。  

**全体解説:**  
契約確立は、仕様定義で確立された要求を実装とテストが共有する「唯一の共通境界」を提供する。  
Contract-Firstの採用は、再現性と独立性を同時に担保し、組織規模や言語差を超えて設計を安定化させる。  

- **サイクル内での位置づけ:**  
  - 仕様段階のMUST要件を実装契約として形式化。  
  - テスト段階でDTO構造を直接利用し、Exampleの妥当性を保証。  
  - 実装段階で契約変更を検知し、破壊的変更を防止。  

- **実務適用例:**  
  - OpenAPI, gRPC, GraphQLなど、仕様駆動型契約を採用。  
  - 自動生成コードをリポジトリに固定し、改変を禁止。  

- **意義:**  
  契約は単なるIF定義ではなく、「仕様と実装を結ぶ証拠」である。  
  これを固定することにより、サイクル全体の再現性と検証可能性を確保する。  

---

### 5.3 テスト策定（Design Tests from Example）
**目的:** 仕様を「例（Example）」として具体化し、関係者間の理解を揃える。  
**採用理由:** BDD（Behavior-Driven Development）を導入し、自然言語で仕様を共有しながら自動テストを設計することで、非技術者も仕様をレビュー可能にするため。  
**キーワード解説:**  
- **Given / When / Then:** 振る舞いを定義するBDDの基本構文。  
  - Given：前提条件  
  - When：実行操作  
  - Then：期待結果  
- **Example:** 実行可能な仕様書。テストと仕様を統合する表現形式。  
- **Feature / Scenario:** BDDの要件粒度単位。  

- Exampleは単なるテストではなく**実行可能な仕様書**。  
- 1シナリオ=1目的を原則とする。  
- QA／開発／ビジネス側で共通にレビュー可能な形式にする。  

**全体解説:**  
テスト策定は「仕様の確認」と「品質の可視化」を同時に成立させる工程である。  
BDDは、仕様とテストを分離せず、「期待結果をExampleで表現する」思想を提供する。  

- **サイクル内での位置づけ:**  
  - 仕様段階のReqIDをFeatureに対応付け、テスト粒度を統一。  
  - 実装段階ではExampleを通過することで、仕様適合を証明。  
  - フィードバック段階でExample結果を仕様更新に反映。  

- **実務適用例:**  
  - Gherkin構文による自動テスト化。  
  - Example結果をCIで集計し、Conformance Matrixに自動反映。  

- **意義:**  
  テスト策定は「仕様理解の翻訳工程」である。  
  BDDを採用することで、開発・QA・ビジネス間の言語的断絶を解消し、サイクルを継続的に回す共通基盤を作る。  

---

### 5.4 実装（Implement via TDD）
**目的:** テストから最小の実装を導き、設計を安全に改善する。  
**採用理由:** TDD（Test-Driven Development）はテストを仕様の最小表現と見なし、実装をその帰結として導くことで、常に仕様と実装の整合を保つため。  
**キーワード解説:**  
- **Red:** 失敗するテストを作成する段階。  
- **Green:** テストを通す最小実装を作成する段階。  
- **Refactor:** 動作を変えずに設計を改善する段階。  
- **Test-Driven:** コードの正しさではなく、要求への適合性を基準に進める思想。  

- Kent BeckのTDDサイクルを採用：  
  1. Red（失敗するテストを作る）  
  2. Green（通す最小実装を書く）  
  3. Refactor（品質を落とさず設計を改善）  
- 各テストには **ReqIDタグ** を付け、Conformance Matrixで追跡可能とする。  
- 実装の進行順序は層語彙（layer_vocab）に従う。  

**全体解説:**  
実装工程は「仕様の再現」であり、「整合性の検証」である。  
TDDの採用により、実装はテストを通じて仕様と常に同期し続ける。  

- **サイクル内での位置づけ:**  
  - Test段階で定義されたExampleを通過するコードのみを許可。  
  - Conformance Matrixを参照し、ReqID未通過コードのマージを禁止。  
  - Feedback段階での改修は、再びRedからやり直すことで品質を保証。  

- **実務適用例:**  
  - CIでRed/Green/Refactorの状態を可視化。  
  - 自動テスト結果をCommit Hookで取得し、Matrixに反映。  

- **意義:**  
  TDDは「設計品質を落とさずに速度を上げる唯一の手法」である。  
  実装をテスト駆動で進めることで、開発速度と品質を両立し、サイクルを止めない。  

---

### 5.5 適合確認（Conformance Testing）
**目的:** 仕様と実装の一致を客観的に証明する。  
**採用理由:** Conformance Testingを導入し、ReqIDをキーに自動テスト群を実行することで、仕様遵守率を定量的に保証するため。  
**キーワード解説:**  
- **ReqID:** 仕様要求を識別するトレーサビリティキー。  
- **Matrix:** ReqID・テスト・実装の対応関係を可視化する表。  
- **CI/CD:** 継続的統合と配信により、自動的に品質検証を行う基盤。  

- ReqIDをキーに、自動テスト群（Conformance Suite）を実行。  
- すべてのMUST要求が通過していることをCIで確認。  
- Matrix例：  
  | ReqID | TestID | ImplRef | Status | CI RunID |  
  |--------|--------|----------|---------|-----------|  
  | API-R001 | ApiClientTests.R001 | ApiClient | ✅ Passed | 2025-10-07-#134 |  
- 100%合格がマージ条件（MUST）。  

**全体解説:**  
適合確認は「サイクルの審判」である。  
仕様・テスト・実装の三者が整合しているかを自動的に判断し、整合率を数値で証明する。  

- **サイクル内での位置づけ:**  
  - 各ReqIDのテスト結果をCIで集約し、合格率100%を保証。  
  - Feedback段階では、この結果を仕様書に反映し、整合履歴を残す。  

- **実務適用例:**  
  - GitHub ActionsやJenkinsで自動テストを実行。  
  - 合格率が100%未満の場合はPRをブロックする。  

- **意義:**  
  適合確認は、主観的レビューに依存しない品質保証の基盤である。  
  これが機能する限り、開発は「常時適合状態（Always Conformant）」を維持できる。  

---

### 5.6 フィードバック（Feedback & Improvement）
**目的:** 実装・テスト結果を仕様へ還流し、継続的改善を維持。  
**採用理由:** フィードバックをサイクルに組み込むことで、仕様・契約・実装の整合性を常に更新し、劣化を防ぐため。  
**キーワード解説:**  
- **Deviation Record:** 仕様逸脱を管理する記録。  
- **ADR (Architecture Decision Record):** 設計上の判断履歴。  
- **Traceability:** 各成果物間の一貫した追跡性。  

- テスト結果・CIログをもとに仕様文書を更新。  
- Conformance Matrixを同一PRで修正し、履歴を一貫させる。  
- 改訂内容は `ChangeLog` または `ADR` に紐づけて記録する。  

**全体解説:**  
フィードバックはSpec–Conformance Cycleを閉じる最後の工程であり、次のサイクルの起点を形成する。  
ここでの目的は「変更を終わらせること」ではなく、「変更を整合性の中に取り込むこと」である。  

- **サイクル内での位置づけ:**  
  - 適合確認で得た結果を仕様へ反映し、次のContract段階の前提条件とする。  
  - ADRで判断履歴を残し、設計変更を追跡可能にする。  
  - Deviation Recordをもとに、再発防止策を体系化。  

- **実務適用例:**  
  - CIで収集したテストログを自動で仕様書に反映。  
  - ADRをリポジトリ管理下に置き、設計変更と一緒に履歴化。  
  - 定期レビューでDeviation項目を確認し、改善ループを維持。  

- **意義:**  
  フィードバック工程は「改善のための閉ループ」であり、サイクル全体を自己修復的に保つ。  
  この工程を怠ると、サイクルは開きっぱなしとなり、仕様の鮮度と信頼性が失われる。  
  よって、フィードバックは「終わり」ではなく、「継続性の開始点」である。  

---

## 6. 継続的検証と品質保証
- CI/CDパイプラインで次を自動検証する：  
  - ReqID命名規則  
  - RFC2119語の整合  
  - 禁止語／破壊的変更の検出  
  - Conformance合格率 = 100%  
- Deviation検知時は `Deviation Record → ADR → 修正PR → 再検証` のプロセスを必ず踏む。  
- これにより「整合性を壊す変更」はマージ不可となる。  

---

## 7. チームの役割とタイミング

| 役割 | 主な責務 | 関与タイミング | 主に関与する手法 |
|------|-----------|----------------|----------------|
| **Spec Author** | 要求をRFC2119で定義、ReqID採番 | 仕様定義 | RFC2119 |
| **System Architect** | 契約（Contract）設計、ADR承認 | 契約確立 | Contract-First |
| **QA / Tester** | Example作成・テスト自動化 | テスト策定～適合確認 | BDD / Conformance Testing |
| **Developer** | TDD実装、Refactor | 実装 | TDD |
| **Tech Lead** | 変更審査・品質保証 | 全段階 | 全手法 |
| **CI Maintainer** | standards-check維持、Matrix検証 | 継続的 | Conformance Testing |

---

## 8. 導入ステップと成熟度モデル

| フェーズ | 状態 | 特徴 | 定量基準（例） |
|-----------|------|------|----------------|
| **Lv1: 文書整備** | RFC2119 で仕様を統一 | 仕様明確化の基礎 | ReqIDカバレッジ ≥ 80% |
| **Lv2: Contract化** | API契約を確立 | 設計の再現性向上 | DTO自動生成率 ≥ 70% |
| **Lv3: Example導入** | BDDでテスト共有 | QAと開発の同期化 | Example対ReqID対応率 ≥ 80% |
| **Lv4: Conformance化** | ReqID単位でCI検証 | 自動品質保証 | Conformance Pass率 = 100% |
| **Lv5: Full SCD** | 全サイクルが常時回転 | 真のSpec–Conformance開発 | 全変更がMatrix追跡済み |

---

## 9. まとめ
Spec–Conformance Cycleは、  
「仕様を守るための手法群」ではなく、  
**「整合性を維持し続ける自己修復サイクル」**である。  

既存手法（RFC2119／BDD／TDD／Contract-First／Conformance Testing）は、  
そのサイクルを支える5つの軸であり、個別に導入しても意味を成さない。  

本ガイドは、特定のプロジェクトに依存せず、  
**すべてのソフトウェア開発およびシステム構築活動に適用可能な「開発プロセス標準書」**として機能する。
目的は常に「サイクルを止めないこと」であり、  
各手法はその目的のために選ばれた最適な手段である。  

---

**Version:** v2.1.0  
**Date:** 2025-10-09  
**Status:** Draft  
